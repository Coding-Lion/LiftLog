@inject IJSRuntime JSRuntime

<button
    class="
        repcount
        w-14
        h-14
        rounded-xl
        relative
        text-center
        bg-primary
        text-xl
        flex
        justify-center
        align-middle
        transition-[box-shadow]
        duration-75
        items-center
        @ColorClass
        @RepCountToStartClass"
    @onpointerdown="OnPointerDown"
    @onpointerleave="OnPointerLeave"
    @onpointerup="OnPointerUp"
    style="box-shadow: inset 0 0 0 @BoxShadowFill var(--md-sys-color-secondary-container);">
    <md-focus-ring @ref="_focusRing" visible=@ToStartNext style="--md-focus-ring-shape: 0.75rem"></md-focus-ring>
    <md-ripple style="--md-ripple-pressed-color: var(--md-sys-color-on-primary-container)" ></md-ripple>
    <span class="font-bold">@(RepCountValue?.ToString() ?? "-")</span><span class="inline text-sm align-text-top">/@MaxReps</span>
</button>
@code {

    private DateTime? _lastPointerDownTime;
    private DateTime? _clearRepCountTime;
    private ElementReference _focusRing;

    [EditorRequired]
    [Parameter]
    public int MaxReps { get; set; }

    [EditorRequired]
    [Parameter]
    public int? RepCountValue { get; set; }

    [EditorRequired]
    [Parameter]
    public Action CycleRepCount { get; set; } = null!;

    [EditorRequired]
    [Parameter]
    public Action ClearRepCount { get; set; } = null!;

    [EditorRequired]
    [Parameter]
    public bool ToStartNext { get; set; }

    private string BoxShadowFill => RepCountValue is not null  ? "0" : "2rem";

    private string ColorClass =>  RepCountValue is not null ? "text-on-primary" : "text-on-secondary-container";

    private string? RepCountToStartClass => ToStartNext ? "" : null;

    private void OnPointerDown(PointerEventArgs args){
        _lastPointerDownTime = DateTime.Now;
        Task.Delay(500).ContinueWith(_ => {
            if (_lastPointerDownTime is null || _lastPointerDownTime.Value.AddMilliseconds(500) > DateTime.Now) return;
            _clearRepCountTime = DateTime.Now;
            ClearRepCount();
        });
    }

    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        if(firstRender)
        {
            await JSRuntime.InvokeVoidAsync("AppUtils.callOn", _focusRing, "detach");
        }
        await base.OnAfterRenderAsync(firstRender);
    }

    private void OnPointerLeave(PointerEventArgs args){
        _lastPointerDownTime = null;
    }

    private void OnPointerUp(PointerEventArgs args){
        if(_clearRepCountTime is null)
        {
            CycleRepCount();
        }
        _clearRepCountTime = null;
        _lastPointerDownTime = null;
    }

}
